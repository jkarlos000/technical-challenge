// Code generated by counterfeiter. DO NOT EDIT.
package beerapifakes

import (
	"sync"

	dbx "github.com/go-ozzo/ozzo-dbx"
)

type FakeBuilder struct {
	AddColumnStub        func(string, string, string) *dbx.Query
	addColumnMutex       sync.RWMutex
	addColumnArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
	}
	addColumnReturns struct {
		result1 *dbx.Query
	}
	addColumnReturnsOnCall map[int]struct {
		result1 *dbx.Query
	}
	AddForeignKeyStub        func(string, string, []string, []string, string, ...string) *dbx.Query
	addForeignKeyMutex       sync.RWMutex
	addForeignKeyArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 []string
		arg4 []string
		arg5 string
		arg6 []string
	}
	addForeignKeyReturns struct {
		result1 *dbx.Query
	}
	addForeignKeyReturnsOnCall map[int]struct {
		result1 *dbx.Query
	}
	AddPrimaryKeyStub        func(string, string, ...string) *dbx.Query
	addPrimaryKeyMutex       sync.RWMutex
	addPrimaryKeyArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 []string
	}
	addPrimaryKeyReturns struct {
		result1 *dbx.Query
	}
	addPrimaryKeyReturnsOnCall map[int]struct {
		result1 *dbx.Query
	}
	AlterColumnStub        func(string, string, string) *dbx.Query
	alterColumnMutex       sync.RWMutex
	alterColumnArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
	}
	alterColumnReturns struct {
		result1 *dbx.Query
	}
	alterColumnReturnsOnCall map[int]struct {
		result1 *dbx.Query
	}
	CreateIndexStub        func(string, string, ...string) *dbx.Query
	createIndexMutex       sync.RWMutex
	createIndexArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 []string
	}
	createIndexReturns struct {
		result1 *dbx.Query
	}
	createIndexReturnsOnCall map[int]struct {
		result1 *dbx.Query
	}
	CreateTableStub        func(string, map[string]string, ...string) *dbx.Query
	createTableMutex       sync.RWMutex
	createTableArgsForCall []struct {
		arg1 string
		arg2 map[string]string
		arg3 []string
	}
	createTableReturns struct {
		result1 *dbx.Query
	}
	createTableReturnsOnCall map[int]struct {
		result1 *dbx.Query
	}
	CreateUniqueIndexStub        func(string, string, ...string) *dbx.Query
	createUniqueIndexMutex       sync.RWMutex
	createUniqueIndexArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 []string
	}
	createUniqueIndexReturns struct {
		result1 *dbx.Query
	}
	createUniqueIndexReturnsOnCall map[int]struct {
		result1 *dbx.Query
	}
	DeleteStub        func(string, dbx.Expression) *dbx.Query
	deleteMutex       sync.RWMutex
	deleteArgsForCall []struct {
		arg1 string
		arg2 dbx.Expression
	}
	deleteReturns struct {
		result1 *dbx.Query
	}
	deleteReturnsOnCall map[int]struct {
		result1 *dbx.Query
	}
	DropColumnStub        func(string, string) *dbx.Query
	dropColumnMutex       sync.RWMutex
	dropColumnArgsForCall []struct {
		arg1 string
		arg2 string
	}
	dropColumnReturns struct {
		result1 *dbx.Query
	}
	dropColumnReturnsOnCall map[int]struct {
		result1 *dbx.Query
	}
	DropForeignKeyStub        func(string, string) *dbx.Query
	dropForeignKeyMutex       sync.RWMutex
	dropForeignKeyArgsForCall []struct {
		arg1 string
		arg2 string
	}
	dropForeignKeyReturns struct {
		result1 *dbx.Query
	}
	dropForeignKeyReturnsOnCall map[int]struct {
		result1 *dbx.Query
	}
	DropIndexStub        func(string, string) *dbx.Query
	dropIndexMutex       sync.RWMutex
	dropIndexArgsForCall []struct {
		arg1 string
		arg2 string
	}
	dropIndexReturns struct {
		result1 *dbx.Query
	}
	dropIndexReturnsOnCall map[int]struct {
		result1 *dbx.Query
	}
	DropPrimaryKeyStub        func(string, string) *dbx.Query
	dropPrimaryKeyMutex       sync.RWMutex
	dropPrimaryKeyArgsForCall []struct {
		arg1 string
		arg2 string
	}
	dropPrimaryKeyReturns struct {
		result1 *dbx.Query
	}
	dropPrimaryKeyReturnsOnCall map[int]struct {
		result1 *dbx.Query
	}
	DropTableStub        func(string) *dbx.Query
	dropTableMutex       sync.RWMutex
	dropTableArgsForCall []struct {
		arg1 string
	}
	dropTableReturns struct {
		result1 *dbx.Query
	}
	dropTableReturnsOnCall map[int]struct {
		result1 *dbx.Query
	}
	GeneratePlaceholderStub        func(int) string
	generatePlaceholderMutex       sync.RWMutex
	generatePlaceholderArgsForCall []struct {
		arg1 int
	}
	generatePlaceholderReturns struct {
		result1 string
	}
	generatePlaceholderReturnsOnCall map[int]struct {
		result1 string
	}
	InsertStub        func(string, dbx.Params) *dbx.Query
	insertMutex       sync.RWMutex
	insertArgsForCall []struct {
		arg1 string
		arg2 dbx.Params
	}
	insertReturns struct {
		result1 *dbx.Query
	}
	insertReturnsOnCall map[int]struct {
		result1 *dbx.Query
	}
	ModelStub        func(interface{}) *dbx.ModelQuery
	modelMutex       sync.RWMutex
	modelArgsForCall []struct {
		arg1 interface{}
	}
	modelReturns struct {
		result1 *dbx.ModelQuery
	}
	modelReturnsOnCall map[int]struct {
		result1 *dbx.ModelQuery
	}
	NewQueryStub        func(string) *dbx.Query
	newQueryMutex       sync.RWMutex
	newQueryArgsForCall []struct {
		arg1 string
	}
	newQueryReturns struct {
		result1 *dbx.Query
	}
	newQueryReturnsOnCall map[int]struct {
		result1 *dbx.Query
	}
	QueryBuilderStub        func() dbx.QueryBuilder
	queryBuilderMutex       sync.RWMutex
	queryBuilderArgsForCall []struct {
	}
	queryBuilderReturns struct {
		result1 dbx.QueryBuilder
	}
	queryBuilderReturnsOnCall map[int]struct {
		result1 dbx.QueryBuilder
	}
	QuoteStub        func(string) string
	quoteMutex       sync.RWMutex
	quoteArgsForCall []struct {
		arg1 string
	}
	quoteReturns struct {
		result1 string
	}
	quoteReturnsOnCall map[int]struct {
		result1 string
	}
	QuoteSimpleColumnNameStub        func(string) string
	quoteSimpleColumnNameMutex       sync.RWMutex
	quoteSimpleColumnNameArgsForCall []struct {
		arg1 string
	}
	quoteSimpleColumnNameReturns struct {
		result1 string
	}
	quoteSimpleColumnNameReturnsOnCall map[int]struct {
		result1 string
	}
	QuoteSimpleTableNameStub        func(string) string
	quoteSimpleTableNameMutex       sync.RWMutex
	quoteSimpleTableNameArgsForCall []struct {
		arg1 string
	}
	quoteSimpleTableNameReturns struct {
		result1 string
	}
	quoteSimpleTableNameReturnsOnCall map[int]struct {
		result1 string
	}
	RenameColumnStub        func(string, string, string) *dbx.Query
	renameColumnMutex       sync.RWMutex
	renameColumnArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
	}
	renameColumnReturns struct {
		result1 *dbx.Query
	}
	renameColumnReturnsOnCall map[int]struct {
		result1 *dbx.Query
	}
	RenameTableStub        func(string, string) *dbx.Query
	renameTableMutex       sync.RWMutex
	renameTableArgsForCall []struct {
		arg1 string
		arg2 string
	}
	renameTableReturns struct {
		result1 *dbx.Query
	}
	renameTableReturnsOnCall map[int]struct {
		result1 *dbx.Query
	}
	SelectStub        func(...string) *dbx.SelectQuery
	selectMutex       sync.RWMutex
	selectArgsForCall []struct {
		arg1 []string
	}
	selectReturns struct {
		result1 *dbx.SelectQuery
	}
	selectReturnsOnCall map[int]struct {
		result1 *dbx.SelectQuery
	}
	TruncateTableStub        func(string) *dbx.Query
	truncateTableMutex       sync.RWMutex
	truncateTableArgsForCall []struct {
		arg1 string
	}
	truncateTableReturns struct {
		result1 *dbx.Query
	}
	truncateTableReturnsOnCall map[int]struct {
		result1 *dbx.Query
	}
	UpdateStub        func(string, dbx.Params, dbx.Expression) *dbx.Query
	updateMutex       sync.RWMutex
	updateArgsForCall []struct {
		arg1 string
		arg2 dbx.Params
		arg3 dbx.Expression
	}
	updateReturns struct {
		result1 *dbx.Query
	}
	updateReturnsOnCall map[int]struct {
		result1 *dbx.Query
	}
	UpsertStub        func(string, dbx.Params, ...string) *dbx.Query
	upsertMutex       sync.RWMutex
	upsertArgsForCall []struct {
		arg1 string
		arg2 dbx.Params
		arg3 []string
	}
	upsertReturns struct {
		result1 *dbx.Query
	}
	upsertReturnsOnCall map[int]struct {
		result1 *dbx.Query
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeBuilder) AddColumn(arg1 string, arg2 string, arg3 string) *dbx.Query {
	fake.addColumnMutex.Lock()
	ret, specificReturn := fake.addColumnReturnsOnCall[len(fake.addColumnArgsForCall)]
	fake.addColumnArgsForCall = append(fake.addColumnArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.AddColumnStub
	fakeReturns := fake.addColumnReturns
	fake.recordInvocation("AddColumn", []interface{}{arg1, arg2, arg3})
	fake.addColumnMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBuilder) AddColumnCallCount() int {
	fake.addColumnMutex.RLock()
	defer fake.addColumnMutex.RUnlock()
	return len(fake.addColumnArgsForCall)
}

func (fake *FakeBuilder) AddColumnCalls(stub func(string, string, string) *dbx.Query) {
	fake.addColumnMutex.Lock()
	defer fake.addColumnMutex.Unlock()
	fake.AddColumnStub = stub
}

func (fake *FakeBuilder) AddColumnArgsForCall(i int) (string, string, string) {
	fake.addColumnMutex.RLock()
	defer fake.addColumnMutex.RUnlock()
	argsForCall := fake.addColumnArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeBuilder) AddColumnReturns(result1 *dbx.Query) {
	fake.addColumnMutex.Lock()
	defer fake.addColumnMutex.Unlock()
	fake.AddColumnStub = nil
	fake.addColumnReturns = struct {
		result1 *dbx.Query
	}{result1}
}

func (fake *FakeBuilder) AddColumnReturnsOnCall(i int, result1 *dbx.Query) {
	fake.addColumnMutex.Lock()
	defer fake.addColumnMutex.Unlock()
	fake.AddColumnStub = nil
	if fake.addColumnReturnsOnCall == nil {
		fake.addColumnReturnsOnCall = make(map[int]struct {
			result1 *dbx.Query
		})
	}
	fake.addColumnReturnsOnCall[i] = struct {
		result1 *dbx.Query
	}{result1}
}

func (fake *FakeBuilder) AddForeignKey(arg1 string, arg2 string, arg3 []string, arg4 []string, arg5 string, arg6 ...string) *dbx.Query {
	var arg3Copy []string
	if arg3 != nil {
		arg3Copy = make([]string, len(arg3))
		copy(arg3Copy, arg3)
	}
	var arg4Copy []string
	if arg4 != nil {
		arg4Copy = make([]string, len(arg4))
		copy(arg4Copy, arg4)
	}
	fake.addForeignKeyMutex.Lock()
	ret, specificReturn := fake.addForeignKeyReturnsOnCall[len(fake.addForeignKeyArgsForCall)]
	fake.addForeignKeyArgsForCall = append(fake.addForeignKeyArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 []string
		arg4 []string
		arg5 string
		arg6 []string
	}{arg1, arg2, arg3Copy, arg4Copy, arg5, arg6})
	stub := fake.AddForeignKeyStub
	fakeReturns := fake.addForeignKeyReturns
	fake.recordInvocation("AddForeignKey", []interface{}{arg1, arg2, arg3Copy, arg4Copy, arg5, arg6})
	fake.addForeignKeyMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5, arg6...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBuilder) AddForeignKeyCallCount() int {
	fake.addForeignKeyMutex.RLock()
	defer fake.addForeignKeyMutex.RUnlock()
	return len(fake.addForeignKeyArgsForCall)
}

func (fake *FakeBuilder) AddForeignKeyCalls(stub func(string, string, []string, []string, string, ...string) *dbx.Query) {
	fake.addForeignKeyMutex.Lock()
	defer fake.addForeignKeyMutex.Unlock()
	fake.AddForeignKeyStub = stub
}

func (fake *FakeBuilder) AddForeignKeyArgsForCall(i int) (string, string, []string, []string, string, []string) {
	fake.addForeignKeyMutex.RLock()
	defer fake.addForeignKeyMutex.RUnlock()
	argsForCall := fake.addForeignKeyArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5, argsForCall.arg6
}

func (fake *FakeBuilder) AddForeignKeyReturns(result1 *dbx.Query) {
	fake.addForeignKeyMutex.Lock()
	defer fake.addForeignKeyMutex.Unlock()
	fake.AddForeignKeyStub = nil
	fake.addForeignKeyReturns = struct {
		result1 *dbx.Query
	}{result1}
}

func (fake *FakeBuilder) AddForeignKeyReturnsOnCall(i int, result1 *dbx.Query) {
	fake.addForeignKeyMutex.Lock()
	defer fake.addForeignKeyMutex.Unlock()
	fake.AddForeignKeyStub = nil
	if fake.addForeignKeyReturnsOnCall == nil {
		fake.addForeignKeyReturnsOnCall = make(map[int]struct {
			result1 *dbx.Query
		})
	}
	fake.addForeignKeyReturnsOnCall[i] = struct {
		result1 *dbx.Query
	}{result1}
}

func (fake *FakeBuilder) AddPrimaryKey(arg1 string, arg2 string, arg3 ...string) *dbx.Query {
	fake.addPrimaryKeyMutex.Lock()
	ret, specificReturn := fake.addPrimaryKeyReturnsOnCall[len(fake.addPrimaryKeyArgsForCall)]
	fake.addPrimaryKeyArgsForCall = append(fake.addPrimaryKeyArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 []string
	}{arg1, arg2, arg3})
	stub := fake.AddPrimaryKeyStub
	fakeReturns := fake.addPrimaryKeyReturns
	fake.recordInvocation("AddPrimaryKey", []interface{}{arg1, arg2, arg3})
	fake.addPrimaryKeyMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBuilder) AddPrimaryKeyCallCount() int {
	fake.addPrimaryKeyMutex.RLock()
	defer fake.addPrimaryKeyMutex.RUnlock()
	return len(fake.addPrimaryKeyArgsForCall)
}

func (fake *FakeBuilder) AddPrimaryKeyCalls(stub func(string, string, ...string) *dbx.Query) {
	fake.addPrimaryKeyMutex.Lock()
	defer fake.addPrimaryKeyMutex.Unlock()
	fake.AddPrimaryKeyStub = stub
}

func (fake *FakeBuilder) AddPrimaryKeyArgsForCall(i int) (string, string, []string) {
	fake.addPrimaryKeyMutex.RLock()
	defer fake.addPrimaryKeyMutex.RUnlock()
	argsForCall := fake.addPrimaryKeyArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeBuilder) AddPrimaryKeyReturns(result1 *dbx.Query) {
	fake.addPrimaryKeyMutex.Lock()
	defer fake.addPrimaryKeyMutex.Unlock()
	fake.AddPrimaryKeyStub = nil
	fake.addPrimaryKeyReturns = struct {
		result1 *dbx.Query
	}{result1}
}

func (fake *FakeBuilder) AddPrimaryKeyReturnsOnCall(i int, result1 *dbx.Query) {
	fake.addPrimaryKeyMutex.Lock()
	defer fake.addPrimaryKeyMutex.Unlock()
	fake.AddPrimaryKeyStub = nil
	if fake.addPrimaryKeyReturnsOnCall == nil {
		fake.addPrimaryKeyReturnsOnCall = make(map[int]struct {
			result1 *dbx.Query
		})
	}
	fake.addPrimaryKeyReturnsOnCall[i] = struct {
		result1 *dbx.Query
	}{result1}
}

func (fake *FakeBuilder) AlterColumn(arg1 string, arg2 string, arg3 string) *dbx.Query {
	fake.alterColumnMutex.Lock()
	ret, specificReturn := fake.alterColumnReturnsOnCall[len(fake.alterColumnArgsForCall)]
	fake.alterColumnArgsForCall = append(fake.alterColumnArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.AlterColumnStub
	fakeReturns := fake.alterColumnReturns
	fake.recordInvocation("AlterColumn", []interface{}{arg1, arg2, arg3})
	fake.alterColumnMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBuilder) AlterColumnCallCount() int {
	fake.alterColumnMutex.RLock()
	defer fake.alterColumnMutex.RUnlock()
	return len(fake.alterColumnArgsForCall)
}

func (fake *FakeBuilder) AlterColumnCalls(stub func(string, string, string) *dbx.Query) {
	fake.alterColumnMutex.Lock()
	defer fake.alterColumnMutex.Unlock()
	fake.AlterColumnStub = stub
}

func (fake *FakeBuilder) AlterColumnArgsForCall(i int) (string, string, string) {
	fake.alterColumnMutex.RLock()
	defer fake.alterColumnMutex.RUnlock()
	argsForCall := fake.alterColumnArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeBuilder) AlterColumnReturns(result1 *dbx.Query) {
	fake.alterColumnMutex.Lock()
	defer fake.alterColumnMutex.Unlock()
	fake.AlterColumnStub = nil
	fake.alterColumnReturns = struct {
		result1 *dbx.Query
	}{result1}
}

func (fake *FakeBuilder) AlterColumnReturnsOnCall(i int, result1 *dbx.Query) {
	fake.alterColumnMutex.Lock()
	defer fake.alterColumnMutex.Unlock()
	fake.AlterColumnStub = nil
	if fake.alterColumnReturnsOnCall == nil {
		fake.alterColumnReturnsOnCall = make(map[int]struct {
			result1 *dbx.Query
		})
	}
	fake.alterColumnReturnsOnCall[i] = struct {
		result1 *dbx.Query
	}{result1}
}

func (fake *FakeBuilder) CreateIndex(arg1 string, arg2 string, arg3 ...string) *dbx.Query {
	fake.createIndexMutex.Lock()
	ret, specificReturn := fake.createIndexReturnsOnCall[len(fake.createIndexArgsForCall)]
	fake.createIndexArgsForCall = append(fake.createIndexArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 []string
	}{arg1, arg2, arg3})
	stub := fake.CreateIndexStub
	fakeReturns := fake.createIndexReturns
	fake.recordInvocation("CreateIndex", []interface{}{arg1, arg2, arg3})
	fake.createIndexMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBuilder) CreateIndexCallCount() int {
	fake.createIndexMutex.RLock()
	defer fake.createIndexMutex.RUnlock()
	return len(fake.createIndexArgsForCall)
}

func (fake *FakeBuilder) CreateIndexCalls(stub func(string, string, ...string) *dbx.Query) {
	fake.createIndexMutex.Lock()
	defer fake.createIndexMutex.Unlock()
	fake.CreateIndexStub = stub
}

func (fake *FakeBuilder) CreateIndexArgsForCall(i int) (string, string, []string) {
	fake.createIndexMutex.RLock()
	defer fake.createIndexMutex.RUnlock()
	argsForCall := fake.createIndexArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeBuilder) CreateIndexReturns(result1 *dbx.Query) {
	fake.createIndexMutex.Lock()
	defer fake.createIndexMutex.Unlock()
	fake.CreateIndexStub = nil
	fake.createIndexReturns = struct {
		result1 *dbx.Query
	}{result1}
}

func (fake *FakeBuilder) CreateIndexReturnsOnCall(i int, result1 *dbx.Query) {
	fake.createIndexMutex.Lock()
	defer fake.createIndexMutex.Unlock()
	fake.CreateIndexStub = nil
	if fake.createIndexReturnsOnCall == nil {
		fake.createIndexReturnsOnCall = make(map[int]struct {
			result1 *dbx.Query
		})
	}
	fake.createIndexReturnsOnCall[i] = struct {
		result1 *dbx.Query
	}{result1}
}

func (fake *FakeBuilder) CreateTable(arg1 string, arg2 map[string]string, arg3 ...string) *dbx.Query {
	fake.createTableMutex.Lock()
	ret, specificReturn := fake.createTableReturnsOnCall[len(fake.createTableArgsForCall)]
	fake.createTableArgsForCall = append(fake.createTableArgsForCall, struct {
		arg1 string
		arg2 map[string]string
		arg3 []string
	}{arg1, arg2, arg3})
	stub := fake.CreateTableStub
	fakeReturns := fake.createTableReturns
	fake.recordInvocation("CreateTable", []interface{}{arg1, arg2, arg3})
	fake.createTableMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBuilder) CreateTableCallCount() int {
	fake.createTableMutex.RLock()
	defer fake.createTableMutex.RUnlock()
	return len(fake.createTableArgsForCall)
}

func (fake *FakeBuilder) CreateTableCalls(stub func(string, map[string]string, ...string) *dbx.Query) {
	fake.createTableMutex.Lock()
	defer fake.createTableMutex.Unlock()
	fake.CreateTableStub = stub
}

func (fake *FakeBuilder) CreateTableArgsForCall(i int) (string, map[string]string, []string) {
	fake.createTableMutex.RLock()
	defer fake.createTableMutex.RUnlock()
	argsForCall := fake.createTableArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeBuilder) CreateTableReturns(result1 *dbx.Query) {
	fake.createTableMutex.Lock()
	defer fake.createTableMutex.Unlock()
	fake.CreateTableStub = nil
	fake.createTableReturns = struct {
		result1 *dbx.Query
	}{result1}
}

func (fake *FakeBuilder) CreateTableReturnsOnCall(i int, result1 *dbx.Query) {
	fake.createTableMutex.Lock()
	defer fake.createTableMutex.Unlock()
	fake.CreateTableStub = nil
	if fake.createTableReturnsOnCall == nil {
		fake.createTableReturnsOnCall = make(map[int]struct {
			result1 *dbx.Query
		})
	}
	fake.createTableReturnsOnCall[i] = struct {
		result1 *dbx.Query
	}{result1}
}

func (fake *FakeBuilder) CreateUniqueIndex(arg1 string, arg2 string, arg3 ...string) *dbx.Query {
	fake.createUniqueIndexMutex.Lock()
	ret, specificReturn := fake.createUniqueIndexReturnsOnCall[len(fake.createUniqueIndexArgsForCall)]
	fake.createUniqueIndexArgsForCall = append(fake.createUniqueIndexArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 []string
	}{arg1, arg2, arg3})
	stub := fake.CreateUniqueIndexStub
	fakeReturns := fake.createUniqueIndexReturns
	fake.recordInvocation("CreateUniqueIndex", []interface{}{arg1, arg2, arg3})
	fake.createUniqueIndexMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBuilder) CreateUniqueIndexCallCount() int {
	fake.createUniqueIndexMutex.RLock()
	defer fake.createUniqueIndexMutex.RUnlock()
	return len(fake.createUniqueIndexArgsForCall)
}

func (fake *FakeBuilder) CreateUniqueIndexCalls(stub func(string, string, ...string) *dbx.Query) {
	fake.createUniqueIndexMutex.Lock()
	defer fake.createUniqueIndexMutex.Unlock()
	fake.CreateUniqueIndexStub = stub
}

func (fake *FakeBuilder) CreateUniqueIndexArgsForCall(i int) (string, string, []string) {
	fake.createUniqueIndexMutex.RLock()
	defer fake.createUniqueIndexMutex.RUnlock()
	argsForCall := fake.createUniqueIndexArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeBuilder) CreateUniqueIndexReturns(result1 *dbx.Query) {
	fake.createUniqueIndexMutex.Lock()
	defer fake.createUniqueIndexMutex.Unlock()
	fake.CreateUniqueIndexStub = nil
	fake.createUniqueIndexReturns = struct {
		result1 *dbx.Query
	}{result1}
}

func (fake *FakeBuilder) CreateUniqueIndexReturnsOnCall(i int, result1 *dbx.Query) {
	fake.createUniqueIndexMutex.Lock()
	defer fake.createUniqueIndexMutex.Unlock()
	fake.CreateUniqueIndexStub = nil
	if fake.createUniqueIndexReturnsOnCall == nil {
		fake.createUniqueIndexReturnsOnCall = make(map[int]struct {
			result1 *dbx.Query
		})
	}
	fake.createUniqueIndexReturnsOnCall[i] = struct {
		result1 *dbx.Query
	}{result1}
}

func (fake *FakeBuilder) Delete(arg1 string, arg2 dbx.Expression) *dbx.Query {
	fake.deleteMutex.Lock()
	ret, specificReturn := fake.deleteReturnsOnCall[len(fake.deleteArgsForCall)]
	fake.deleteArgsForCall = append(fake.deleteArgsForCall, struct {
		arg1 string
		arg2 dbx.Expression
	}{arg1, arg2})
	stub := fake.DeleteStub
	fakeReturns := fake.deleteReturns
	fake.recordInvocation("Delete", []interface{}{arg1, arg2})
	fake.deleteMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBuilder) DeleteCallCount() int {
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	return len(fake.deleteArgsForCall)
}

func (fake *FakeBuilder) DeleteCalls(stub func(string, dbx.Expression) *dbx.Query) {
	fake.deleteMutex.Lock()
	defer fake.deleteMutex.Unlock()
	fake.DeleteStub = stub
}

func (fake *FakeBuilder) DeleteArgsForCall(i int) (string, dbx.Expression) {
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	argsForCall := fake.deleteArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeBuilder) DeleteReturns(result1 *dbx.Query) {
	fake.deleteMutex.Lock()
	defer fake.deleteMutex.Unlock()
	fake.DeleteStub = nil
	fake.deleteReturns = struct {
		result1 *dbx.Query
	}{result1}
}

func (fake *FakeBuilder) DeleteReturnsOnCall(i int, result1 *dbx.Query) {
	fake.deleteMutex.Lock()
	defer fake.deleteMutex.Unlock()
	fake.DeleteStub = nil
	if fake.deleteReturnsOnCall == nil {
		fake.deleteReturnsOnCall = make(map[int]struct {
			result1 *dbx.Query
		})
	}
	fake.deleteReturnsOnCall[i] = struct {
		result1 *dbx.Query
	}{result1}
}

func (fake *FakeBuilder) DropColumn(arg1 string, arg2 string) *dbx.Query {
	fake.dropColumnMutex.Lock()
	ret, specificReturn := fake.dropColumnReturnsOnCall[len(fake.dropColumnArgsForCall)]
	fake.dropColumnArgsForCall = append(fake.dropColumnArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.DropColumnStub
	fakeReturns := fake.dropColumnReturns
	fake.recordInvocation("DropColumn", []interface{}{arg1, arg2})
	fake.dropColumnMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBuilder) DropColumnCallCount() int {
	fake.dropColumnMutex.RLock()
	defer fake.dropColumnMutex.RUnlock()
	return len(fake.dropColumnArgsForCall)
}

func (fake *FakeBuilder) DropColumnCalls(stub func(string, string) *dbx.Query) {
	fake.dropColumnMutex.Lock()
	defer fake.dropColumnMutex.Unlock()
	fake.DropColumnStub = stub
}

func (fake *FakeBuilder) DropColumnArgsForCall(i int) (string, string) {
	fake.dropColumnMutex.RLock()
	defer fake.dropColumnMutex.RUnlock()
	argsForCall := fake.dropColumnArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeBuilder) DropColumnReturns(result1 *dbx.Query) {
	fake.dropColumnMutex.Lock()
	defer fake.dropColumnMutex.Unlock()
	fake.DropColumnStub = nil
	fake.dropColumnReturns = struct {
		result1 *dbx.Query
	}{result1}
}

func (fake *FakeBuilder) DropColumnReturnsOnCall(i int, result1 *dbx.Query) {
	fake.dropColumnMutex.Lock()
	defer fake.dropColumnMutex.Unlock()
	fake.DropColumnStub = nil
	if fake.dropColumnReturnsOnCall == nil {
		fake.dropColumnReturnsOnCall = make(map[int]struct {
			result1 *dbx.Query
		})
	}
	fake.dropColumnReturnsOnCall[i] = struct {
		result1 *dbx.Query
	}{result1}
}

func (fake *FakeBuilder) DropForeignKey(arg1 string, arg2 string) *dbx.Query {
	fake.dropForeignKeyMutex.Lock()
	ret, specificReturn := fake.dropForeignKeyReturnsOnCall[len(fake.dropForeignKeyArgsForCall)]
	fake.dropForeignKeyArgsForCall = append(fake.dropForeignKeyArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.DropForeignKeyStub
	fakeReturns := fake.dropForeignKeyReturns
	fake.recordInvocation("DropForeignKey", []interface{}{arg1, arg2})
	fake.dropForeignKeyMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBuilder) DropForeignKeyCallCount() int {
	fake.dropForeignKeyMutex.RLock()
	defer fake.dropForeignKeyMutex.RUnlock()
	return len(fake.dropForeignKeyArgsForCall)
}

func (fake *FakeBuilder) DropForeignKeyCalls(stub func(string, string) *dbx.Query) {
	fake.dropForeignKeyMutex.Lock()
	defer fake.dropForeignKeyMutex.Unlock()
	fake.DropForeignKeyStub = stub
}

func (fake *FakeBuilder) DropForeignKeyArgsForCall(i int) (string, string) {
	fake.dropForeignKeyMutex.RLock()
	defer fake.dropForeignKeyMutex.RUnlock()
	argsForCall := fake.dropForeignKeyArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeBuilder) DropForeignKeyReturns(result1 *dbx.Query) {
	fake.dropForeignKeyMutex.Lock()
	defer fake.dropForeignKeyMutex.Unlock()
	fake.DropForeignKeyStub = nil
	fake.dropForeignKeyReturns = struct {
		result1 *dbx.Query
	}{result1}
}

func (fake *FakeBuilder) DropForeignKeyReturnsOnCall(i int, result1 *dbx.Query) {
	fake.dropForeignKeyMutex.Lock()
	defer fake.dropForeignKeyMutex.Unlock()
	fake.DropForeignKeyStub = nil
	if fake.dropForeignKeyReturnsOnCall == nil {
		fake.dropForeignKeyReturnsOnCall = make(map[int]struct {
			result1 *dbx.Query
		})
	}
	fake.dropForeignKeyReturnsOnCall[i] = struct {
		result1 *dbx.Query
	}{result1}
}

func (fake *FakeBuilder) DropIndex(arg1 string, arg2 string) *dbx.Query {
	fake.dropIndexMutex.Lock()
	ret, specificReturn := fake.dropIndexReturnsOnCall[len(fake.dropIndexArgsForCall)]
	fake.dropIndexArgsForCall = append(fake.dropIndexArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.DropIndexStub
	fakeReturns := fake.dropIndexReturns
	fake.recordInvocation("DropIndex", []interface{}{arg1, arg2})
	fake.dropIndexMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBuilder) DropIndexCallCount() int {
	fake.dropIndexMutex.RLock()
	defer fake.dropIndexMutex.RUnlock()
	return len(fake.dropIndexArgsForCall)
}

func (fake *FakeBuilder) DropIndexCalls(stub func(string, string) *dbx.Query) {
	fake.dropIndexMutex.Lock()
	defer fake.dropIndexMutex.Unlock()
	fake.DropIndexStub = stub
}

func (fake *FakeBuilder) DropIndexArgsForCall(i int) (string, string) {
	fake.dropIndexMutex.RLock()
	defer fake.dropIndexMutex.RUnlock()
	argsForCall := fake.dropIndexArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeBuilder) DropIndexReturns(result1 *dbx.Query) {
	fake.dropIndexMutex.Lock()
	defer fake.dropIndexMutex.Unlock()
	fake.DropIndexStub = nil
	fake.dropIndexReturns = struct {
		result1 *dbx.Query
	}{result1}
}

func (fake *FakeBuilder) DropIndexReturnsOnCall(i int, result1 *dbx.Query) {
	fake.dropIndexMutex.Lock()
	defer fake.dropIndexMutex.Unlock()
	fake.DropIndexStub = nil
	if fake.dropIndexReturnsOnCall == nil {
		fake.dropIndexReturnsOnCall = make(map[int]struct {
			result1 *dbx.Query
		})
	}
	fake.dropIndexReturnsOnCall[i] = struct {
		result1 *dbx.Query
	}{result1}
}

func (fake *FakeBuilder) DropPrimaryKey(arg1 string, arg2 string) *dbx.Query {
	fake.dropPrimaryKeyMutex.Lock()
	ret, specificReturn := fake.dropPrimaryKeyReturnsOnCall[len(fake.dropPrimaryKeyArgsForCall)]
	fake.dropPrimaryKeyArgsForCall = append(fake.dropPrimaryKeyArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.DropPrimaryKeyStub
	fakeReturns := fake.dropPrimaryKeyReturns
	fake.recordInvocation("DropPrimaryKey", []interface{}{arg1, arg2})
	fake.dropPrimaryKeyMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBuilder) DropPrimaryKeyCallCount() int {
	fake.dropPrimaryKeyMutex.RLock()
	defer fake.dropPrimaryKeyMutex.RUnlock()
	return len(fake.dropPrimaryKeyArgsForCall)
}

func (fake *FakeBuilder) DropPrimaryKeyCalls(stub func(string, string) *dbx.Query) {
	fake.dropPrimaryKeyMutex.Lock()
	defer fake.dropPrimaryKeyMutex.Unlock()
	fake.DropPrimaryKeyStub = stub
}

func (fake *FakeBuilder) DropPrimaryKeyArgsForCall(i int) (string, string) {
	fake.dropPrimaryKeyMutex.RLock()
	defer fake.dropPrimaryKeyMutex.RUnlock()
	argsForCall := fake.dropPrimaryKeyArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeBuilder) DropPrimaryKeyReturns(result1 *dbx.Query) {
	fake.dropPrimaryKeyMutex.Lock()
	defer fake.dropPrimaryKeyMutex.Unlock()
	fake.DropPrimaryKeyStub = nil
	fake.dropPrimaryKeyReturns = struct {
		result1 *dbx.Query
	}{result1}
}

func (fake *FakeBuilder) DropPrimaryKeyReturnsOnCall(i int, result1 *dbx.Query) {
	fake.dropPrimaryKeyMutex.Lock()
	defer fake.dropPrimaryKeyMutex.Unlock()
	fake.DropPrimaryKeyStub = nil
	if fake.dropPrimaryKeyReturnsOnCall == nil {
		fake.dropPrimaryKeyReturnsOnCall = make(map[int]struct {
			result1 *dbx.Query
		})
	}
	fake.dropPrimaryKeyReturnsOnCall[i] = struct {
		result1 *dbx.Query
	}{result1}
}

func (fake *FakeBuilder) DropTable(arg1 string) *dbx.Query {
	fake.dropTableMutex.Lock()
	ret, specificReturn := fake.dropTableReturnsOnCall[len(fake.dropTableArgsForCall)]
	fake.dropTableArgsForCall = append(fake.dropTableArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.DropTableStub
	fakeReturns := fake.dropTableReturns
	fake.recordInvocation("DropTable", []interface{}{arg1})
	fake.dropTableMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBuilder) DropTableCallCount() int {
	fake.dropTableMutex.RLock()
	defer fake.dropTableMutex.RUnlock()
	return len(fake.dropTableArgsForCall)
}

func (fake *FakeBuilder) DropTableCalls(stub func(string) *dbx.Query) {
	fake.dropTableMutex.Lock()
	defer fake.dropTableMutex.Unlock()
	fake.DropTableStub = stub
}

func (fake *FakeBuilder) DropTableArgsForCall(i int) string {
	fake.dropTableMutex.RLock()
	defer fake.dropTableMutex.RUnlock()
	argsForCall := fake.dropTableArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeBuilder) DropTableReturns(result1 *dbx.Query) {
	fake.dropTableMutex.Lock()
	defer fake.dropTableMutex.Unlock()
	fake.DropTableStub = nil
	fake.dropTableReturns = struct {
		result1 *dbx.Query
	}{result1}
}

func (fake *FakeBuilder) DropTableReturnsOnCall(i int, result1 *dbx.Query) {
	fake.dropTableMutex.Lock()
	defer fake.dropTableMutex.Unlock()
	fake.DropTableStub = nil
	if fake.dropTableReturnsOnCall == nil {
		fake.dropTableReturnsOnCall = make(map[int]struct {
			result1 *dbx.Query
		})
	}
	fake.dropTableReturnsOnCall[i] = struct {
		result1 *dbx.Query
	}{result1}
}

func (fake *FakeBuilder) GeneratePlaceholder(arg1 int) string {
	fake.generatePlaceholderMutex.Lock()
	ret, specificReturn := fake.generatePlaceholderReturnsOnCall[len(fake.generatePlaceholderArgsForCall)]
	fake.generatePlaceholderArgsForCall = append(fake.generatePlaceholderArgsForCall, struct {
		arg1 int
	}{arg1})
	stub := fake.GeneratePlaceholderStub
	fakeReturns := fake.generatePlaceholderReturns
	fake.recordInvocation("GeneratePlaceholder", []interface{}{arg1})
	fake.generatePlaceholderMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBuilder) GeneratePlaceholderCallCount() int {
	fake.generatePlaceholderMutex.RLock()
	defer fake.generatePlaceholderMutex.RUnlock()
	return len(fake.generatePlaceholderArgsForCall)
}

func (fake *FakeBuilder) GeneratePlaceholderCalls(stub func(int) string) {
	fake.generatePlaceholderMutex.Lock()
	defer fake.generatePlaceholderMutex.Unlock()
	fake.GeneratePlaceholderStub = stub
}

func (fake *FakeBuilder) GeneratePlaceholderArgsForCall(i int) int {
	fake.generatePlaceholderMutex.RLock()
	defer fake.generatePlaceholderMutex.RUnlock()
	argsForCall := fake.generatePlaceholderArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeBuilder) GeneratePlaceholderReturns(result1 string) {
	fake.generatePlaceholderMutex.Lock()
	defer fake.generatePlaceholderMutex.Unlock()
	fake.GeneratePlaceholderStub = nil
	fake.generatePlaceholderReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeBuilder) GeneratePlaceholderReturnsOnCall(i int, result1 string) {
	fake.generatePlaceholderMutex.Lock()
	defer fake.generatePlaceholderMutex.Unlock()
	fake.GeneratePlaceholderStub = nil
	if fake.generatePlaceholderReturnsOnCall == nil {
		fake.generatePlaceholderReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.generatePlaceholderReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeBuilder) Insert(arg1 string, arg2 dbx.Params) *dbx.Query {
	fake.insertMutex.Lock()
	ret, specificReturn := fake.insertReturnsOnCall[len(fake.insertArgsForCall)]
	fake.insertArgsForCall = append(fake.insertArgsForCall, struct {
		arg1 string
		arg2 dbx.Params
	}{arg1, arg2})
	stub := fake.InsertStub
	fakeReturns := fake.insertReturns
	fake.recordInvocation("Insert", []interface{}{arg1, arg2})
	fake.insertMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBuilder) InsertCallCount() int {
	fake.insertMutex.RLock()
	defer fake.insertMutex.RUnlock()
	return len(fake.insertArgsForCall)
}

func (fake *FakeBuilder) InsertCalls(stub func(string, dbx.Params) *dbx.Query) {
	fake.insertMutex.Lock()
	defer fake.insertMutex.Unlock()
	fake.InsertStub = stub
}

func (fake *FakeBuilder) InsertArgsForCall(i int) (string, dbx.Params) {
	fake.insertMutex.RLock()
	defer fake.insertMutex.RUnlock()
	argsForCall := fake.insertArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeBuilder) InsertReturns(result1 *dbx.Query) {
	fake.insertMutex.Lock()
	defer fake.insertMutex.Unlock()
	fake.InsertStub = nil
	fake.insertReturns = struct {
		result1 *dbx.Query
	}{result1}
}

func (fake *FakeBuilder) InsertReturnsOnCall(i int, result1 *dbx.Query) {
	fake.insertMutex.Lock()
	defer fake.insertMutex.Unlock()
	fake.InsertStub = nil
	if fake.insertReturnsOnCall == nil {
		fake.insertReturnsOnCall = make(map[int]struct {
			result1 *dbx.Query
		})
	}
	fake.insertReturnsOnCall[i] = struct {
		result1 *dbx.Query
	}{result1}
}

func (fake *FakeBuilder) Model(arg1 interface{}) *dbx.ModelQuery {
	fake.modelMutex.Lock()
	ret, specificReturn := fake.modelReturnsOnCall[len(fake.modelArgsForCall)]
	fake.modelArgsForCall = append(fake.modelArgsForCall, struct {
		arg1 interface{}
	}{arg1})
	stub := fake.ModelStub
	fakeReturns := fake.modelReturns
	fake.recordInvocation("Model", []interface{}{arg1})
	fake.modelMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBuilder) ModelCallCount() int {
	fake.modelMutex.RLock()
	defer fake.modelMutex.RUnlock()
	return len(fake.modelArgsForCall)
}

func (fake *FakeBuilder) ModelCalls(stub func(interface{}) *dbx.ModelQuery) {
	fake.modelMutex.Lock()
	defer fake.modelMutex.Unlock()
	fake.ModelStub = stub
}

func (fake *FakeBuilder) ModelArgsForCall(i int) interface{} {
	fake.modelMutex.RLock()
	defer fake.modelMutex.RUnlock()
	argsForCall := fake.modelArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeBuilder) ModelReturns(result1 *dbx.ModelQuery) {
	fake.modelMutex.Lock()
	defer fake.modelMutex.Unlock()
	fake.ModelStub = nil
	fake.modelReturns = struct {
		result1 *dbx.ModelQuery
	}{result1}
}

func (fake *FakeBuilder) ModelReturnsOnCall(i int, result1 *dbx.ModelQuery) {
	fake.modelMutex.Lock()
	defer fake.modelMutex.Unlock()
	fake.ModelStub = nil
	if fake.modelReturnsOnCall == nil {
		fake.modelReturnsOnCall = make(map[int]struct {
			result1 *dbx.ModelQuery
		})
	}
	fake.modelReturnsOnCall[i] = struct {
		result1 *dbx.ModelQuery
	}{result1}
}

func (fake *FakeBuilder) NewQuery(arg1 string) *dbx.Query {
	fake.newQueryMutex.Lock()
	ret, specificReturn := fake.newQueryReturnsOnCall[len(fake.newQueryArgsForCall)]
	fake.newQueryArgsForCall = append(fake.newQueryArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.NewQueryStub
	fakeReturns := fake.newQueryReturns
	fake.recordInvocation("NewQuery", []interface{}{arg1})
	fake.newQueryMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBuilder) NewQueryCallCount() int {
	fake.newQueryMutex.RLock()
	defer fake.newQueryMutex.RUnlock()
	return len(fake.newQueryArgsForCall)
}

func (fake *FakeBuilder) NewQueryCalls(stub func(string) *dbx.Query) {
	fake.newQueryMutex.Lock()
	defer fake.newQueryMutex.Unlock()
	fake.NewQueryStub = stub
}

func (fake *FakeBuilder) NewQueryArgsForCall(i int) string {
	fake.newQueryMutex.RLock()
	defer fake.newQueryMutex.RUnlock()
	argsForCall := fake.newQueryArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeBuilder) NewQueryReturns(result1 *dbx.Query) {
	fake.newQueryMutex.Lock()
	defer fake.newQueryMutex.Unlock()
	fake.NewQueryStub = nil
	fake.newQueryReturns = struct {
		result1 *dbx.Query
	}{result1}
}

func (fake *FakeBuilder) NewQueryReturnsOnCall(i int, result1 *dbx.Query) {
	fake.newQueryMutex.Lock()
	defer fake.newQueryMutex.Unlock()
	fake.NewQueryStub = nil
	if fake.newQueryReturnsOnCall == nil {
		fake.newQueryReturnsOnCall = make(map[int]struct {
			result1 *dbx.Query
		})
	}
	fake.newQueryReturnsOnCall[i] = struct {
		result1 *dbx.Query
	}{result1}
}

func (fake *FakeBuilder) QueryBuilder() dbx.QueryBuilder {
	fake.queryBuilderMutex.Lock()
	ret, specificReturn := fake.queryBuilderReturnsOnCall[len(fake.queryBuilderArgsForCall)]
	fake.queryBuilderArgsForCall = append(fake.queryBuilderArgsForCall, struct {
	}{})
	stub := fake.QueryBuilderStub
	fakeReturns := fake.queryBuilderReturns
	fake.recordInvocation("QueryBuilder", []interface{}{})
	fake.queryBuilderMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBuilder) QueryBuilderCallCount() int {
	fake.queryBuilderMutex.RLock()
	defer fake.queryBuilderMutex.RUnlock()
	return len(fake.queryBuilderArgsForCall)
}

func (fake *FakeBuilder) QueryBuilderCalls(stub func() dbx.QueryBuilder) {
	fake.queryBuilderMutex.Lock()
	defer fake.queryBuilderMutex.Unlock()
	fake.QueryBuilderStub = stub
}

func (fake *FakeBuilder) QueryBuilderReturns(result1 dbx.QueryBuilder) {
	fake.queryBuilderMutex.Lock()
	defer fake.queryBuilderMutex.Unlock()
	fake.QueryBuilderStub = nil
	fake.queryBuilderReturns = struct {
		result1 dbx.QueryBuilder
	}{result1}
}

func (fake *FakeBuilder) QueryBuilderReturnsOnCall(i int, result1 dbx.QueryBuilder) {
	fake.queryBuilderMutex.Lock()
	defer fake.queryBuilderMutex.Unlock()
	fake.QueryBuilderStub = nil
	if fake.queryBuilderReturnsOnCall == nil {
		fake.queryBuilderReturnsOnCall = make(map[int]struct {
			result1 dbx.QueryBuilder
		})
	}
	fake.queryBuilderReturnsOnCall[i] = struct {
		result1 dbx.QueryBuilder
	}{result1}
}

func (fake *FakeBuilder) Quote(arg1 string) string {
	fake.quoteMutex.Lock()
	ret, specificReturn := fake.quoteReturnsOnCall[len(fake.quoteArgsForCall)]
	fake.quoteArgsForCall = append(fake.quoteArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.QuoteStub
	fakeReturns := fake.quoteReturns
	fake.recordInvocation("Quote", []interface{}{arg1})
	fake.quoteMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBuilder) QuoteCallCount() int {
	fake.quoteMutex.RLock()
	defer fake.quoteMutex.RUnlock()
	return len(fake.quoteArgsForCall)
}

func (fake *FakeBuilder) QuoteCalls(stub func(string) string) {
	fake.quoteMutex.Lock()
	defer fake.quoteMutex.Unlock()
	fake.QuoteStub = stub
}

func (fake *FakeBuilder) QuoteArgsForCall(i int) string {
	fake.quoteMutex.RLock()
	defer fake.quoteMutex.RUnlock()
	argsForCall := fake.quoteArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeBuilder) QuoteReturns(result1 string) {
	fake.quoteMutex.Lock()
	defer fake.quoteMutex.Unlock()
	fake.QuoteStub = nil
	fake.quoteReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeBuilder) QuoteReturnsOnCall(i int, result1 string) {
	fake.quoteMutex.Lock()
	defer fake.quoteMutex.Unlock()
	fake.QuoteStub = nil
	if fake.quoteReturnsOnCall == nil {
		fake.quoteReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.quoteReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeBuilder) QuoteSimpleColumnName(arg1 string) string {
	fake.quoteSimpleColumnNameMutex.Lock()
	ret, specificReturn := fake.quoteSimpleColumnNameReturnsOnCall[len(fake.quoteSimpleColumnNameArgsForCall)]
	fake.quoteSimpleColumnNameArgsForCall = append(fake.quoteSimpleColumnNameArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.QuoteSimpleColumnNameStub
	fakeReturns := fake.quoteSimpleColumnNameReturns
	fake.recordInvocation("QuoteSimpleColumnName", []interface{}{arg1})
	fake.quoteSimpleColumnNameMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBuilder) QuoteSimpleColumnNameCallCount() int {
	fake.quoteSimpleColumnNameMutex.RLock()
	defer fake.quoteSimpleColumnNameMutex.RUnlock()
	return len(fake.quoteSimpleColumnNameArgsForCall)
}

func (fake *FakeBuilder) QuoteSimpleColumnNameCalls(stub func(string) string) {
	fake.quoteSimpleColumnNameMutex.Lock()
	defer fake.quoteSimpleColumnNameMutex.Unlock()
	fake.QuoteSimpleColumnNameStub = stub
}

func (fake *FakeBuilder) QuoteSimpleColumnNameArgsForCall(i int) string {
	fake.quoteSimpleColumnNameMutex.RLock()
	defer fake.quoteSimpleColumnNameMutex.RUnlock()
	argsForCall := fake.quoteSimpleColumnNameArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeBuilder) QuoteSimpleColumnNameReturns(result1 string) {
	fake.quoteSimpleColumnNameMutex.Lock()
	defer fake.quoteSimpleColumnNameMutex.Unlock()
	fake.QuoteSimpleColumnNameStub = nil
	fake.quoteSimpleColumnNameReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeBuilder) QuoteSimpleColumnNameReturnsOnCall(i int, result1 string) {
	fake.quoteSimpleColumnNameMutex.Lock()
	defer fake.quoteSimpleColumnNameMutex.Unlock()
	fake.QuoteSimpleColumnNameStub = nil
	if fake.quoteSimpleColumnNameReturnsOnCall == nil {
		fake.quoteSimpleColumnNameReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.quoteSimpleColumnNameReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeBuilder) QuoteSimpleTableName(arg1 string) string {
	fake.quoteSimpleTableNameMutex.Lock()
	ret, specificReturn := fake.quoteSimpleTableNameReturnsOnCall[len(fake.quoteSimpleTableNameArgsForCall)]
	fake.quoteSimpleTableNameArgsForCall = append(fake.quoteSimpleTableNameArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.QuoteSimpleTableNameStub
	fakeReturns := fake.quoteSimpleTableNameReturns
	fake.recordInvocation("QuoteSimpleTableName", []interface{}{arg1})
	fake.quoteSimpleTableNameMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBuilder) QuoteSimpleTableNameCallCount() int {
	fake.quoteSimpleTableNameMutex.RLock()
	defer fake.quoteSimpleTableNameMutex.RUnlock()
	return len(fake.quoteSimpleTableNameArgsForCall)
}

func (fake *FakeBuilder) QuoteSimpleTableNameCalls(stub func(string) string) {
	fake.quoteSimpleTableNameMutex.Lock()
	defer fake.quoteSimpleTableNameMutex.Unlock()
	fake.QuoteSimpleTableNameStub = stub
}

func (fake *FakeBuilder) QuoteSimpleTableNameArgsForCall(i int) string {
	fake.quoteSimpleTableNameMutex.RLock()
	defer fake.quoteSimpleTableNameMutex.RUnlock()
	argsForCall := fake.quoteSimpleTableNameArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeBuilder) QuoteSimpleTableNameReturns(result1 string) {
	fake.quoteSimpleTableNameMutex.Lock()
	defer fake.quoteSimpleTableNameMutex.Unlock()
	fake.QuoteSimpleTableNameStub = nil
	fake.quoteSimpleTableNameReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeBuilder) QuoteSimpleTableNameReturnsOnCall(i int, result1 string) {
	fake.quoteSimpleTableNameMutex.Lock()
	defer fake.quoteSimpleTableNameMutex.Unlock()
	fake.QuoteSimpleTableNameStub = nil
	if fake.quoteSimpleTableNameReturnsOnCall == nil {
		fake.quoteSimpleTableNameReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.quoteSimpleTableNameReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeBuilder) RenameColumn(arg1 string, arg2 string, arg3 string) *dbx.Query {
	fake.renameColumnMutex.Lock()
	ret, specificReturn := fake.renameColumnReturnsOnCall[len(fake.renameColumnArgsForCall)]
	fake.renameColumnArgsForCall = append(fake.renameColumnArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.RenameColumnStub
	fakeReturns := fake.renameColumnReturns
	fake.recordInvocation("RenameColumn", []interface{}{arg1, arg2, arg3})
	fake.renameColumnMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBuilder) RenameColumnCallCount() int {
	fake.renameColumnMutex.RLock()
	defer fake.renameColumnMutex.RUnlock()
	return len(fake.renameColumnArgsForCall)
}

func (fake *FakeBuilder) RenameColumnCalls(stub func(string, string, string) *dbx.Query) {
	fake.renameColumnMutex.Lock()
	defer fake.renameColumnMutex.Unlock()
	fake.RenameColumnStub = stub
}

func (fake *FakeBuilder) RenameColumnArgsForCall(i int) (string, string, string) {
	fake.renameColumnMutex.RLock()
	defer fake.renameColumnMutex.RUnlock()
	argsForCall := fake.renameColumnArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeBuilder) RenameColumnReturns(result1 *dbx.Query) {
	fake.renameColumnMutex.Lock()
	defer fake.renameColumnMutex.Unlock()
	fake.RenameColumnStub = nil
	fake.renameColumnReturns = struct {
		result1 *dbx.Query
	}{result1}
}

func (fake *FakeBuilder) RenameColumnReturnsOnCall(i int, result1 *dbx.Query) {
	fake.renameColumnMutex.Lock()
	defer fake.renameColumnMutex.Unlock()
	fake.RenameColumnStub = nil
	if fake.renameColumnReturnsOnCall == nil {
		fake.renameColumnReturnsOnCall = make(map[int]struct {
			result1 *dbx.Query
		})
	}
	fake.renameColumnReturnsOnCall[i] = struct {
		result1 *dbx.Query
	}{result1}
}

func (fake *FakeBuilder) RenameTable(arg1 string, arg2 string) *dbx.Query {
	fake.renameTableMutex.Lock()
	ret, specificReturn := fake.renameTableReturnsOnCall[len(fake.renameTableArgsForCall)]
	fake.renameTableArgsForCall = append(fake.renameTableArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.RenameTableStub
	fakeReturns := fake.renameTableReturns
	fake.recordInvocation("RenameTable", []interface{}{arg1, arg2})
	fake.renameTableMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBuilder) RenameTableCallCount() int {
	fake.renameTableMutex.RLock()
	defer fake.renameTableMutex.RUnlock()
	return len(fake.renameTableArgsForCall)
}

func (fake *FakeBuilder) RenameTableCalls(stub func(string, string) *dbx.Query) {
	fake.renameTableMutex.Lock()
	defer fake.renameTableMutex.Unlock()
	fake.RenameTableStub = stub
}

func (fake *FakeBuilder) RenameTableArgsForCall(i int) (string, string) {
	fake.renameTableMutex.RLock()
	defer fake.renameTableMutex.RUnlock()
	argsForCall := fake.renameTableArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeBuilder) RenameTableReturns(result1 *dbx.Query) {
	fake.renameTableMutex.Lock()
	defer fake.renameTableMutex.Unlock()
	fake.RenameTableStub = nil
	fake.renameTableReturns = struct {
		result1 *dbx.Query
	}{result1}
}

func (fake *FakeBuilder) RenameTableReturnsOnCall(i int, result1 *dbx.Query) {
	fake.renameTableMutex.Lock()
	defer fake.renameTableMutex.Unlock()
	fake.RenameTableStub = nil
	if fake.renameTableReturnsOnCall == nil {
		fake.renameTableReturnsOnCall = make(map[int]struct {
			result1 *dbx.Query
		})
	}
	fake.renameTableReturnsOnCall[i] = struct {
		result1 *dbx.Query
	}{result1}
}

func (fake *FakeBuilder) Select(arg1 ...string) *dbx.SelectQuery {
	fake.selectMutex.Lock()
	ret, specificReturn := fake.selectReturnsOnCall[len(fake.selectArgsForCall)]
	fake.selectArgsForCall = append(fake.selectArgsForCall, struct {
		arg1 []string
	}{arg1})
	stub := fake.SelectStub
	fakeReturns := fake.selectReturns
	fake.recordInvocation("Select", []interface{}{arg1})
	fake.selectMutex.Unlock()
	if stub != nil {
		return stub(arg1...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBuilder) SelectCallCount() int {
	fake.selectMutex.RLock()
	defer fake.selectMutex.RUnlock()
	return len(fake.selectArgsForCall)
}

func (fake *FakeBuilder) SelectCalls(stub func(...string) *dbx.SelectQuery) {
	fake.selectMutex.Lock()
	defer fake.selectMutex.Unlock()
	fake.SelectStub = stub
}

func (fake *FakeBuilder) SelectArgsForCall(i int) []string {
	fake.selectMutex.RLock()
	defer fake.selectMutex.RUnlock()
	argsForCall := fake.selectArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeBuilder) SelectReturns(result1 *dbx.SelectQuery) {
	fake.selectMutex.Lock()
	defer fake.selectMutex.Unlock()
	fake.SelectStub = nil
	fake.selectReturns = struct {
		result1 *dbx.SelectQuery
	}{result1}
}

func (fake *FakeBuilder) SelectReturnsOnCall(i int, result1 *dbx.SelectQuery) {
	fake.selectMutex.Lock()
	defer fake.selectMutex.Unlock()
	fake.SelectStub = nil
	if fake.selectReturnsOnCall == nil {
		fake.selectReturnsOnCall = make(map[int]struct {
			result1 *dbx.SelectQuery
		})
	}
	fake.selectReturnsOnCall[i] = struct {
		result1 *dbx.SelectQuery
	}{result1}
}

func (fake *FakeBuilder) TruncateTable(arg1 string) *dbx.Query {
	fake.truncateTableMutex.Lock()
	ret, specificReturn := fake.truncateTableReturnsOnCall[len(fake.truncateTableArgsForCall)]
	fake.truncateTableArgsForCall = append(fake.truncateTableArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.TruncateTableStub
	fakeReturns := fake.truncateTableReturns
	fake.recordInvocation("TruncateTable", []interface{}{arg1})
	fake.truncateTableMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBuilder) TruncateTableCallCount() int {
	fake.truncateTableMutex.RLock()
	defer fake.truncateTableMutex.RUnlock()
	return len(fake.truncateTableArgsForCall)
}

func (fake *FakeBuilder) TruncateTableCalls(stub func(string) *dbx.Query) {
	fake.truncateTableMutex.Lock()
	defer fake.truncateTableMutex.Unlock()
	fake.TruncateTableStub = stub
}

func (fake *FakeBuilder) TruncateTableArgsForCall(i int) string {
	fake.truncateTableMutex.RLock()
	defer fake.truncateTableMutex.RUnlock()
	argsForCall := fake.truncateTableArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeBuilder) TruncateTableReturns(result1 *dbx.Query) {
	fake.truncateTableMutex.Lock()
	defer fake.truncateTableMutex.Unlock()
	fake.TruncateTableStub = nil
	fake.truncateTableReturns = struct {
		result1 *dbx.Query
	}{result1}
}

func (fake *FakeBuilder) TruncateTableReturnsOnCall(i int, result1 *dbx.Query) {
	fake.truncateTableMutex.Lock()
	defer fake.truncateTableMutex.Unlock()
	fake.TruncateTableStub = nil
	if fake.truncateTableReturnsOnCall == nil {
		fake.truncateTableReturnsOnCall = make(map[int]struct {
			result1 *dbx.Query
		})
	}
	fake.truncateTableReturnsOnCall[i] = struct {
		result1 *dbx.Query
	}{result1}
}

func (fake *FakeBuilder) Update(arg1 string, arg2 dbx.Params, arg3 dbx.Expression) *dbx.Query {
	fake.updateMutex.Lock()
	ret, specificReturn := fake.updateReturnsOnCall[len(fake.updateArgsForCall)]
	fake.updateArgsForCall = append(fake.updateArgsForCall, struct {
		arg1 string
		arg2 dbx.Params
		arg3 dbx.Expression
	}{arg1, arg2, arg3})
	stub := fake.UpdateStub
	fakeReturns := fake.updateReturns
	fake.recordInvocation("Update", []interface{}{arg1, arg2, arg3})
	fake.updateMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBuilder) UpdateCallCount() int {
	fake.updateMutex.RLock()
	defer fake.updateMutex.RUnlock()
	return len(fake.updateArgsForCall)
}

func (fake *FakeBuilder) UpdateCalls(stub func(string, dbx.Params, dbx.Expression) *dbx.Query) {
	fake.updateMutex.Lock()
	defer fake.updateMutex.Unlock()
	fake.UpdateStub = stub
}

func (fake *FakeBuilder) UpdateArgsForCall(i int) (string, dbx.Params, dbx.Expression) {
	fake.updateMutex.RLock()
	defer fake.updateMutex.RUnlock()
	argsForCall := fake.updateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeBuilder) UpdateReturns(result1 *dbx.Query) {
	fake.updateMutex.Lock()
	defer fake.updateMutex.Unlock()
	fake.UpdateStub = nil
	fake.updateReturns = struct {
		result1 *dbx.Query
	}{result1}
}

func (fake *FakeBuilder) UpdateReturnsOnCall(i int, result1 *dbx.Query) {
	fake.updateMutex.Lock()
	defer fake.updateMutex.Unlock()
	fake.UpdateStub = nil
	if fake.updateReturnsOnCall == nil {
		fake.updateReturnsOnCall = make(map[int]struct {
			result1 *dbx.Query
		})
	}
	fake.updateReturnsOnCall[i] = struct {
		result1 *dbx.Query
	}{result1}
}

func (fake *FakeBuilder) Upsert(arg1 string, arg2 dbx.Params, arg3 ...string) *dbx.Query {
	fake.upsertMutex.Lock()
	ret, specificReturn := fake.upsertReturnsOnCall[len(fake.upsertArgsForCall)]
	fake.upsertArgsForCall = append(fake.upsertArgsForCall, struct {
		arg1 string
		arg2 dbx.Params
		arg3 []string
	}{arg1, arg2, arg3})
	stub := fake.UpsertStub
	fakeReturns := fake.upsertReturns
	fake.recordInvocation("Upsert", []interface{}{arg1, arg2, arg3})
	fake.upsertMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBuilder) UpsertCallCount() int {
	fake.upsertMutex.RLock()
	defer fake.upsertMutex.RUnlock()
	return len(fake.upsertArgsForCall)
}

func (fake *FakeBuilder) UpsertCalls(stub func(string, dbx.Params, ...string) *dbx.Query) {
	fake.upsertMutex.Lock()
	defer fake.upsertMutex.Unlock()
	fake.UpsertStub = stub
}

func (fake *FakeBuilder) UpsertArgsForCall(i int) (string, dbx.Params, []string) {
	fake.upsertMutex.RLock()
	defer fake.upsertMutex.RUnlock()
	argsForCall := fake.upsertArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeBuilder) UpsertReturns(result1 *dbx.Query) {
	fake.upsertMutex.Lock()
	defer fake.upsertMutex.Unlock()
	fake.UpsertStub = nil
	fake.upsertReturns = struct {
		result1 *dbx.Query
	}{result1}
}

func (fake *FakeBuilder) UpsertReturnsOnCall(i int, result1 *dbx.Query) {
	fake.upsertMutex.Lock()
	defer fake.upsertMutex.Unlock()
	fake.UpsertStub = nil
	if fake.upsertReturnsOnCall == nil {
		fake.upsertReturnsOnCall = make(map[int]struct {
			result1 *dbx.Query
		})
	}
	fake.upsertReturnsOnCall[i] = struct {
		result1 *dbx.Query
	}{result1}
}

func (fake *FakeBuilder) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.addColumnMutex.RLock()
	defer fake.addColumnMutex.RUnlock()
	fake.addForeignKeyMutex.RLock()
	defer fake.addForeignKeyMutex.RUnlock()
	fake.addPrimaryKeyMutex.RLock()
	defer fake.addPrimaryKeyMutex.RUnlock()
	fake.alterColumnMutex.RLock()
	defer fake.alterColumnMutex.RUnlock()
	fake.createIndexMutex.RLock()
	defer fake.createIndexMutex.RUnlock()
	fake.createTableMutex.RLock()
	defer fake.createTableMutex.RUnlock()
	fake.createUniqueIndexMutex.RLock()
	defer fake.createUniqueIndexMutex.RUnlock()
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	fake.dropColumnMutex.RLock()
	defer fake.dropColumnMutex.RUnlock()
	fake.dropForeignKeyMutex.RLock()
	defer fake.dropForeignKeyMutex.RUnlock()
	fake.dropIndexMutex.RLock()
	defer fake.dropIndexMutex.RUnlock()
	fake.dropPrimaryKeyMutex.RLock()
	defer fake.dropPrimaryKeyMutex.RUnlock()
	fake.dropTableMutex.RLock()
	defer fake.dropTableMutex.RUnlock()
	fake.generatePlaceholderMutex.RLock()
	defer fake.generatePlaceholderMutex.RUnlock()
	fake.insertMutex.RLock()
	defer fake.insertMutex.RUnlock()
	fake.modelMutex.RLock()
	defer fake.modelMutex.RUnlock()
	fake.newQueryMutex.RLock()
	defer fake.newQueryMutex.RUnlock()
	fake.queryBuilderMutex.RLock()
	defer fake.queryBuilderMutex.RUnlock()
	fake.quoteMutex.RLock()
	defer fake.quoteMutex.RUnlock()
	fake.quoteSimpleColumnNameMutex.RLock()
	defer fake.quoteSimpleColumnNameMutex.RUnlock()
	fake.quoteSimpleTableNameMutex.RLock()
	defer fake.quoteSimpleTableNameMutex.RUnlock()
	fake.renameColumnMutex.RLock()
	defer fake.renameColumnMutex.RUnlock()
	fake.renameTableMutex.RLock()
	defer fake.renameTableMutex.RUnlock()
	fake.selectMutex.RLock()
	defer fake.selectMutex.RUnlock()
	fake.truncateTableMutex.RLock()
	defer fake.truncateTableMutex.RUnlock()
	fake.updateMutex.RLock()
	defer fake.updateMutex.RUnlock()
	fake.upsertMutex.RLock()
	defer fake.upsertMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeBuilder) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ dbx.Builder = new(FakeBuilder)
